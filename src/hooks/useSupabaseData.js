import { useState, useEffect, useCallback } from 'react';
import { projectsService, testimonialsService, talksService, settingsService, isSupabaseConfigured } from '../lib/supabase';
// Sistema de eventos globais para sincroniza√ß√£o
class DataSyncManager {
    constructor() {
        this.listeners = new Set();
        this.lastUpdate = 0;
    }
    subscribe(callback) {
        this.listeners.add(callback);
        return () => this.listeners.delete(callback);
    }
    notify() {
        this.lastUpdate = Date.now();
        console.log('üîÑ FOR√áANDO atualiza√ß√£o de TODOS os componentes...');
        this.listeners.forEach(callback => {
            try {
                callback();
            }
            catch (error) {
                console.error('Erro ao notificar listener:', error);
            }
        });
    }
    getLastUpdate() {
        return this.lastUpdate;
    }
}
const dataSyncManager = new DataSyncManager();
// Hook para for√ßar re-render
const useForceUpdate = () => {
    const [, setTick] = useState(0);
    const forceUpdate = useCallback(() => {
        setTick(tick => tick + 1);
    }, []);
    return forceUpdate;
};
// DADOS PADR√ÉO APENAS PARA CASOS DE ERRO CR√çTICO
const DEFAULT_DATA = {
    projects: [],
    testimonials: [],
    talks: [],
    settings: {
        id: 1,
        site_title: "DevIem - Desenvolvedor ‚Ä¢ Mentor ‚Ä¢ Especialista em IA ‚Ä¢ Ethical Hacker",
        site_description: "20+ anos de experi√™ncia em desenvolvimento, mentoria em transi√ß√£o de carreira, especialista em IA e cybersecurity.",
        hero_title: "DEVIEM",
        hero_subtitle: "Desenvolvedor ‚Ä¢ Mentor ‚Ä¢ Especialista em IA ‚Ä¢ Ethical Hacker",
        about_text: "Mais de 20 anos transformando ideias em realidade digital",
        skills: [
            "JavaScript/TypeScript", "Python", "Java", "C#", "PHP", "React", "Angular", "Vue.js",
            "Node.js", "Spring Boot", ".NET", "Laravel", "Docker", "Kubernetes", "AWS", "Azure",
            "Machine Learning", "AI Tools", "Cybersecurity", "Ethical Hacking", "Penetration Testing"
        ]
    }
};
export const useProjects = () => {
    const [projects, setProjects] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const forceUpdate = useForceUpdate();
    const fetchProjects = useCallback(async (force = false) => {
        try {
            if (force)
                console.log('üîÑ FOR√áANDO atualiza√ß√£o de projetos...');
            setLoading(true);
            setError(null);
            if (!isSupabaseConfigured()) {
                console.error('‚ùå Supabase n√£o configurado - usando dados padr√£o');
                setProjects(DEFAULT_DATA.projects);
                setError('Supabase n√£o configurado');
                setLoading(false);
                return;
            }
            console.log('üåê Buscando projetos do Supabase...');
            const data = await projectsService.getAll();
            if (data) {
                setProjects(data);
                console.log('üìä Projetos carregados do Supabase:', data.length);
            }
            else {
                setProjects([]);
                console.log('üìä Nenhum projeto encontrado no Supabase');
            }
            forceUpdate();
        }
        catch (err) {
            console.error('‚ùå Erro ao carregar projetos:', err);
            setError(err instanceof Error ? err.message : 'Erro ao carregar projetos');
            setProjects(DEFAULT_DATA.projects);
        }
        finally {
            setLoading(false);
        }
    }, [forceUpdate]);
    useEffect(() => {
        fetchProjects();
        const unsubscribe = dataSyncManager.subscribe(() => {
            console.log('üîÑ Recebido evento de sync - atualizando projetos...');
            fetchProjects(true);
        });
        return unsubscribe;
    }, [fetchProjects]);
    const addProject = async (project) => {
        try {
            if (!isSupabaseConfigured()) {
                throw new Error('Supabase n√£o configurado');
            }
            console.log('‚ûï Adicionando projeto no Supabase:', project.title);
            const newProject = await projectsService.create(project);
            if (newProject) {
                console.log('‚úÖ Projeto adicionado com sucesso no Supabase');
                await fetchProjects(true);
                dataSyncManager.notify();
                return newProject;
            }
            else {
                throw new Error('Falha ao criar projeto no Supabase');
            }
        }
        catch (err) {
            console.error('‚ùå Erro ao adicionar projeto:', err);
            throw err;
        }
    };
    const updateProject = async (id, project) => {
        try {
            if (!isSupabaseConfigured()) {
                throw new Error('Supabase n√£o configurado');
            }
            console.log('üìù Atualizando projeto no Supabase:', id);
            const updatedProject = await projectsService.update(id, project);
            if (updatedProject) {
                console.log('‚úÖ Projeto atualizado com sucesso no Supabase');
                await fetchProjects(true);
                dataSyncManager.notify();
                return updatedProject;
            }
            else {
                throw new Error('Falha ao atualizar projeto no Supabase');
            }
        }
        catch (err) {
            console.error('‚ùå Erro ao atualizar projeto:', err);
            throw err;
        }
    };
    const deleteProject = async (id) => {
        try {
            if (!isSupabaseConfigured()) {
                throw new Error('Supabase n√£o configurado');
            }
            console.log('üóëÔ∏è Deletando projeto no Supabase:', id);
            await projectsService.delete(id);
            console.log('‚úÖ Projeto deletado com sucesso no Supabase');
            await fetchProjects(true);
            dataSyncManager.notify();
        }
        catch (err) {
            console.error('‚ùå Erro ao deletar projeto:', err);
            throw err;
        }
    };
    return {
        projects,
        loading,
        error,
        addProject,
        updateProject,
        deleteProject,
        refetch: fetchProjects
    };
};
export const useTestimonials = () => {
    const [testimonials, setTestimonials] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const forceUpdate = useForceUpdate();
    const fetchTestimonials = useCallback(async (force = false) => {
        try {
            if (force)
                console.log('üîÑ FOR√áANDO atualiza√ß√£o de depoimentos...');
            setLoading(true);
            setError(null);
            if (!isSupabaseConfigured()) {
                console.error('‚ùå Supabase n√£o configurado - usando dados padr√£o');
                setTestimonials(DEFAULT_DATA.testimonials);
                setError('Supabase n√£o configurado');
                setLoading(false);
                return;
            }
            console.log('üåê Buscando depoimentos do Supabase...');
            const data = await testimonialsService.getAll();
            if (data) {
                setTestimonials(data);
                console.log('üìä Depoimentos carregados do Supabase:', data.length);
            }
            else {
                setTestimonials([]);
                console.log('üìä Nenhum depoimento encontrado no Supabase');
            }
            forceUpdate();
        }
        catch (err) {
            console.error('‚ùå Erro ao carregar depoimentos:', err);
            setError(err instanceof Error ? err.message : 'Erro ao carregar depoimentos');
            setTestimonials(DEFAULT_DATA.testimonials);
        }
        finally {
            setLoading(false);
        }
    }, [forceUpdate]);
    useEffect(() => {
        fetchTestimonials();
        const unsubscribe = dataSyncManager.subscribe(() => {
            console.log('üîÑ Recebido evento de sync - atualizando depoimentos...');
            fetchTestimonials(true);
        });
        return unsubscribe;
    }, [fetchTestimonials]);
    const addTestimonial = async (testimonial) => {
        try {
            if (!isSupabaseConfigured()) {
                throw new Error('Supabase n√£o configurado');
            }
            console.log('‚ûï Adicionando depoimento no Supabase:', testimonial.name);
            const newTestimonial = await testimonialsService.create(testimonial);
            if (newTestimonial) {
                console.log('‚úÖ Depoimento adicionado com sucesso no Supabase');
                await fetchTestimonials(true);
                dataSyncManager.notify();
                return newTestimonial;
            }
            else {
                throw new Error('Falha ao criar depoimento no Supabase');
            }
        }
        catch (err) {
            console.error('‚ùå Erro ao adicionar depoimento:', err);
            throw err;
        }
    };
    const updateTestimonial = async (id, testimonial) => {
        try {
            if (!isSupabaseConfigured()) {
                throw new Error('Supabase n√£o configurado');
            }
            console.log('üìù Atualizando depoimento no Supabase:', id);
            const updatedTestimonial = await testimonialsService.update(id, testimonial);
            if (updatedTestimonial) {
                console.log('‚úÖ Depoimento atualizado com sucesso no Supabase');
                await fetchTestimonials(true);
                dataSyncManager.notify();
                return updatedTestimonial;
            }
            else {
                throw new Error('Falha ao atualizar depoimento no Supabase');
            }
        }
        catch (err) {
            console.error('‚ùå Erro ao atualizar depoimento:', err);
            throw err;
        }
    };
    const deleteTestimonial = async (id) => {
        try {
            if (!isSupabaseConfigured()) {
                throw new Error('Supabase n√£o configurado');
            }
            console.log('üóëÔ∏è Deletando depoimento no Supabase:', id);
            await testimonialsService.delete(id);
            console.log('‚úÖ Depoimento deletado com sucesso no Supabase');
            await fetchTestimonials(true);
            dataSyncManager.notify();
        }
        catch (err) {
            console.error('‚ùå Erro ao deletar depoimento:', err);
            throw err;
        }
    };
    return {
        testimonials,
        loading,
        error,
        addTestimonial,
        updateTestimonial,
        deleteTestimonial,
        refetch: fetchTestimonials
    };
};
export const useTalks = () => {
    const [talks, setTalks] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const forceUpdate = useForceUpdate();
    const fetchTalks = useCallback(async (force = false) => {
        try {
            if (force)
                console.log('üîÑ FOR√áANDO atualiza√ß√£o de palestras...');
            setLoading(true);
            setError(null);
            if (!isSupabaseConfigured()) {
                console.error('‚ùå Supabase n√£o configurado - usando dados padr√£o');
                setTalks(DEFAULT_DATA.talks);
                setError('Supabase n√£o configurado');
                setLoading(false);
                return;
            }
            console.log('üåê Buscando palestras do Supabase...');
            const data = await talksService.getAll();
            if (data) {
                setTalks(data);
                console.log('üìä Palestras carregadas do Supabase:', data.length);
            }
            else {
                setTalks([]);
                console.log('üìä Nenhuma palestra encontrada no Supabase');
            }
            forceUpdate();
        }
        catch (err) {
            console.error('‚ùå Erro ao carregar palestras:', err);
            setError(err instanceof Error ? err.message : 'Erro ao carregar palestras');
            setTalks(DEFAULT_DATA.talks);
        }
        finally {
            setLoading(false);
        }
    }, [forceUpdate]);
    useEffect(() => {
        fetchTalks();
        const unsubscribe = dataSyncManager.subscribe(() => {
            console.log('üîÑ Recebido evento de sync - atualizando palestras...');
            fetchTalks(true);
        });
        return unsubscribe;
    }, [fetchTalks]);
    const addTalk = async (talk) => {
        try {
            if (!isSupabaseConfigured()) {
                throw new Error('Supabase n√£o configurado');
            }
            console.log('‚ûï Adicionando palestra no Supabase:', talk.title);
            const newTalk = await talksService.create(talk);
            if (newTalk) {
                console.log('‚úÖ Palestra adicionada com sucesso no Supabase');
                await fetchTalks(true);
                dataSyncManager.notify();
                return newTalk;
            }
            else {
                throw new Error('Falha ao criar palestra no Supabase');
            }
        }
        catch (err) {
            console.error('‚ùå Erro ao adicionar palestra:', err);
            throw err;
        }
    };
    const updateTalk = async (id, talk) => {
        try {
            if (!isSupabaseConfigured()) {
                throw new Error('Supabase n√£o configurado');
            }
            console.log('üìù Atualizando palestra no Supabase:', id);
            const updatedTalk = await talksService.update(id, talk);
            if (updatedTalk) {
                console.log('‚úÖ Palestra atualizada com sucesso no Supabase');
                await fetchTalks(true);
                dataSyncManager.notify();
                return updatedTalk;
            }
            else {
                throw new Error('Falha ao atualizar palestra no Supabase');
            }
        }
        catch (err) {
            console.error('‚ùå Erro ao atualizar palestra:', err);
            throw err;
        }
    };
    const deleteTalk = async (id) => {
        try {
            if (!isSupabaseConfigured()) {
                throw new Error('Supabase n√£o configurado');
            }
            console.log('üóëÔ∏è Deletando palestra no Supabase:', id);
            await talksService.delete(id);
            console.log('‚úÖ Palestra deletada com sucesso no Supabase');
            await fetchTalks(true);
            dataSyncManager.notify();
        }
        catch (err) {
            console.error('‚ùå Erro ao deletar palestra:', err);
            throw err;
        }
    };
    return {
        talks,
        loading,
        error,
        addTalk,
        updateTalk,
        deleteTalk,
        refetch: fetchTalks
    };
};
export const useSiteSettings = () => {
    const [settings, setSettings] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const forceUpdate = useForceUpdate();
    const fetchSettings = useCallback(async (force = false) => {
        try {
            if (force)
                console.log('üîÑ FOR√áANDO atualiza√ß√£o de configura√ß√µes...');
            setLoading(true);
            setError(null);
            if (!isSupabaseConfigured()) {
                console.error('‚ùå Supabase n√£o configurado - usando configura√ß√µes padr√£o');
                setSettings(DEFAULT_DATA.settings);
                setError('Supabase n√£o configurado');
                setLoading(false);
                return;
            }
            console.log('üåê Buscando configura√ß√µes do Supabase...');
            const data = await settingsService.get();
            if (data) {
                setSettings(data);
                console.log('üìä Configura√ß√µes carregadas do Supabase');
            }
            else {
                setSettings(DEFAULT_DATA.settings);
                console.log('üìä Usando configura√ß√µes padr√£o');
            }
            forceUpdate();
        }
        catch (err) {
            console.error('‚ùå Erro ao carregar configura√ß√µes:', err);
            setError(err instanceof Error ? err.message : 'Erro ao carregar configura√ß√µes');
            setSettings(DEFAULT_DATA.settings);
        }
        finally {
            setLoading(false);
        }
    }, [forceUpdate]);
    useEffect(() => {
        fetchSettings();
        const unsubscribe = dataSyncManager.subscribe(() => {
            console.log('üîÑ Recebido evento de sync - atualizando configura√ß√µes...');
            fetchSettings(true);
        });
        return unsubscribe;
    }, [fetchSettings]);
    const updateSettings = async (newSettings) => {
        try {
            if (!isSupabaseConfigured()) {
                throw new Error('Supabase n√£o configurado');
            }
            console.log('üìù Atualizando configura√ß√µes no Supabase');
            const updatedSettings = await settingsService.update(newSettings);
            if (updatedSettings) {
                console.log('‚úÖ Configura√ß√µes atualizadas com sucesso no Supabase');
                await fetchSettings(true);
                dataSyncManager.notify();
                return updatedSettings;
            }
            else {
                throw new Error('Falha ao atualizar configura√ß√µes no Supabase');
            }
        }
        catch (err) {
            console.error('‚ùå Erro ao atualizar configura√ß√µes:', err);
            throw err;
        }
    };
    return {
        settings,
        loading,
        error,
        updateSettings,
        refetch: fetchSettings
    };
};
// Hook para sincroniza√ß√£o global de dados
export const useDataSync = () => {
    const [isRefreshing, setIsRefreshing] = useState(false);
    const syncAllData = async () => {
        try {
            setIsRefreshing(true);
            console.log('üîÑ SINCRONIZA√á√ÉO GLOBAL INICIADA...');
            dataSyncManager.notify();
            await new Promise(resolve => setTimeout(resolve, 1000));
            console.log('‚úÖ Sincroniza√ß√£o global conclu√≠da');
        }
        catch (error) {
            console.error('‚ùå Erro ao sincronizar dados:', error);
        }
        finally {
            setIsRefreshing(false);
        }
    };
    return { syncAllData, isRefreshing };
};
// Hook simplificado para o frontend
export const useFrontendData = () => {
    const { projects } = useProjects();
    const { testimonials } = useTestimonials();
    const { talks } = useTalks();
    const { settings } = useSiteSettings();
    const refreshAllData = useCallback(() => {
        console.log('üîÑ FOR√áANDO refresh TOTAL de todos os dados do frontend...');
        dataSyncManager.notify();
    }, []);
    return {
        projects,
        testimonials,
        talks,
        settings,
        refreshAllData
    };
};
